#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
#       moncli
#       
#       Copyright 2011 Jelle Smet <development@smetj.net>
#       
#       This program is free software; you can redistribute it and/or modify
#       it under the terms of the GNU General Public License as published by
#       the Free Software Foundation; either version 3 of the License, or
#       (at your option) any later version.
#       
#       This program is distributed in the hope that it will be useful,
#       but WITHOUT ANY WARRANTY; without even the implied warranty of
#       MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#       GNU General Public License for more details.
#       
#       You should have received a copy of the GNU General Public License
#       along with this program; if not, write to the Free Software
#       Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
#       MA 02110-1301, USA.
#       
#

from optparse import OptionParser
import os
import sys
import daemon
import time
import logging


class Server():
    '''Starts the whole program and blocks from exiting'''
    def __init__(self, config=None, log_file=True, log_screen=True):
        self.config = config
        self.log_file = log_file
        self.log_screen = log_screen
        self.thread_block = True
        tools.logger(file=self.config['log'],
            scrlog=self.log_screen, txtlog=self.log_file)
        self.logging = logging.getLogger(__name__)

    def checkRunning(self):
        try:
            if os.path.exists(self.config['pid']):
                pidfile = open(self.config['pid'], 'r')
                pid = pidfile.readline()
                pidfile.close()
                try:
                    os.kill(int(pid), 0)
                except OSError:
                    try:
                        os.remove(self.config['pid'])
                    except Exception as err:
                        sys.stderr.write('I could not delete pid %s. Reason: %s\n' % (self.config['pid'], err))
                        sys.exit(1)
                else:
                    sys.stderr.write('There is already a version of Moncli running with PID %s\n' % (pid))
                    sys.exit(1)
        except Exception as err:
            sys.stderr.write('There was a problem handling the PID file.  Reason: %s\n' % (str(err)))
            sys.exit(1)

    def block(self):
        return self.thread_block

    def stop(self):
        sys.stdout.write('Stopping all queues in a polite way. Sending a Sigint (2) again will make me exit (or moncli stop).\n')
        try:
            pidfile = open(self.config['pid'], 'r')
            os.kill(int(pidfile.readline()), 2)
            pidfile.close()
        except Exception as err:
            sys.stdout.write('I could not stop Moncli. Reason: %s\n' % (err))

    def start(self):
        #Enable profiling.
        #from tools import Profile
        #prof = Profile()

        sys.path.append(self.config['lib'])

        #Create pid
        pidfile = open(self.config['pid'], 'w')
        pidfile.write(str(os.getpid()))
        pidfile.close()
        broker = None
        scheduler = None
        while self.block() == True:
            #try:
                #Initialize Broker
                broker = engine.Broker(host=self.config['broker'])

                #Setup scheduler
                scheduler = engine.JobScheduler(cache_file=self.config['cache'])

                #Schedule all incoming report requests
                broker.addToScheduler = getattr(scheduler, 'do')

                #Send reports back to broker
                scheduler.submitBroker = getattr(broker, 'submitReport')

                #Load the scheduler cache if available.
                scheduler.load()

                #Start consuming and block
                broker.connection.ioloop.start()

            #except KeyboardInterrupt:
                #scheduler.shutdown()
                #self.thread_block = False
                #broker.connection.close()
                #broker.connection.ioloop.start()
                #scheduler.shutdown()
                #os.remove(self.config['pid'])
                #sys.exit
            #except:
                #if broker.connection.is_open == True:
                    #broker.connection.close()
                    #broker.connection.ioloop.start()
                #if scheduler != None:
                    #scheduler.shutdown()
                #self.logging.warn("Broker connection failed, restarting")
                #time.sleep(1)

if __name__ == '__main__':
    try:
        #Parse command line options
        parser = OptionParser()
        parser.add_option("--broker", dest="broker", default="127.0.0.1", type="string", help="IPaddress or hostname of the broker to connect to.  Default is localhost.")
        parser.add_option("--local_repo", dest="local_repository", default=os.getcwd() + '/', type="string", help="Location of the local plugin repository.")
        parser.add_option("--remote_repo", dest="remote_repository", default=None, type="string", help="Location of the remote plugin repository.")
        parser.add_option("--cache", dest="cache", default=os.getcwd() + '/moncli.cache', type="string", help="Scheduler configuration cache.")
        parser.add_option("--pid", dest="pid", default=os.getcwd() + "/moncli.pid", type="string", help="The location of the pid file.")
        parser.add_option("--log", dest="log", default=os.getcwd() + "/moncli.log", type="string", help="The location of the log file.")
        parser.add_option("--lib", dest='lib', default='/opt/moncli/lib', type='string', help="The library path to include to the search.")
        parser.add_option("--rand_window", dest='rand_window', default='60', type='string', help="The value in seconds which is added to the first schedule of a job in order to spread jobs.")

        cli_options, cli_actions = parser.parse_args()
        config = vars(cli_options)

        ##Extend path environment
        sys.path.append(cli_options.lib)
        from moncli import engine
        from moncli import tools
        from moncli import event
        from moncli.help import help
        server = Server(config=config)

        #Execute command
        if len(cli_actions) != 1:
            help()
            sys.exit
        elif cli_actions[0] == 'start':
            print ("Starting Moncli in background.")
            server.log_screen = False
            server.checkRunning()
            with daemon.DaemonContext():
                server.start()
        elif cli_actions[0] == 'debug':
            print ("Starting Moncli in foreground.")
            server.checkRunning()
            server.start()
        elif cli_actions[0] == 'stop':
            print ("Stopping Moncli gracefully.  Tail log for progress.")
            server.stop()
        elif cli_actions[0] == 'kill':
            print ("Killing Moncli forcefully.")
            server.kill()
        elif cli_actions[0] == 'dump':
            pass
        else:
            help()
            print ('Unknown option %s \n' % (cli_actions[0]))
            sys.exit()
    except Exception as err:
        sys.stderr.write('A fatal error has occurred.\n')
        sys.stderr.write('Please file a bug report to https://github.com/smetj/Moncli/issues including:\n')
        sys.stderr.write('\t - Moncli version.\n')
        sys.stderr.write('\t - Startup parameters.\n')
        sys.stderr.write('\t - A copy of your moncli.cache file.\n')
        sys.stderr.write('\t - Your OS and version.\n')
        sys.stderr.write('\t - Your Python version.\n')
        sys.stderr.write('\t - The steps to take to reproduce this error.\n')
        sys.stderr.write('\t - This piece of information: '+ str(type(err))+" "+str(err) + "\n" )
        #sys.stderr.write(str(traceback.print_exc()))
        sys.exit(1)
